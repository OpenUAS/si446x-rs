//! Simple example which transmits a 4-byte message at ~433MHz with CRC on a STM32F103 using a Si4463 radio
#![no_main]
#![no_std]

use si446x::Si446x;
use stm32f103xx_hal::prelude::*;
use stm32f103xx_hal::delay::Delay;
use stm32f103xx_hal::spi::{Mode, Phase, Polarity, Spi};
use cortex_m_rt::entry;

const INIT_VECTOR_PKT_433MHZ: [u8; 365] = [ // Generated by WDS
    0x07, 0x02, 0x01, 0x00, 0x01, 0x8C, 0xBA, 0x80, 0x01, 0x10, 0x08, 0x13, 0x01, 0x01, 0x01, 0x01,
    0x67, 0x00, 0x00, 0x06, 0x11, 0x00, 0x02, 0x00, 0x52, 0x40, 0x05, 0x11, 0x00, 0x01, 0x03, 0x60,
    0x06, 0x11, 0x01, 0x02, 0x00, 0x01, 0x18, 0x08, 0x11, 0x02, 0x04, 0x00, 0x03, 0x04, 0x05, 0x0A,
    0x0D, 0x11, 0x10, 0x09, 0x00, 0x08, 0x14, 0x00, 0x0F, 0x31, 0x00, 0x00, 0x00, 0x00, 0x09, 0x11,
    0x11, 0x05, 0x00, 0x01, 0xB4, 0x2B, 0x00, 0x00, 0x0B, 0x11, 0x12, 0x07, 0x00, 0x84, 0x01, 0x08,
    0xFF, 0xFF, 0x00, 0x02, 0x10, 0x11, 0x12, 0x0C, 0x08, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x04,
    0x04, 0xAA, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x0C, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x0C, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x11, 0x12, 0x09, 0x2C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x20, 0x0C, 0x00, 0x03, 0x00, 0x07, 0x06, 0x1A, 0x80,
    0x05, 0x8C, 0xBA, 0x80, 0x00, 0x06, 0x05, 0x11, 0x20, 0x01, 0x0C, 0x4D, 0x0C, 0x11, 0x20, 0x08,
    0x18, 0x01, 0x80, 0x08, 0x03, 0x80, 0x00, 0x20, 0x20, 0x0D, 0x11, 0x20, 0x09, 0x22, 0x01, 0x45,
    0x01, 0x93, 0x4C, 0x00, 0xCA, 0x02, 0xC2, 0x0B, 0x11, 0x20, 0x07, 0x2C, 0x04, 0x36, 0x80, 0x22,
    0x0F, 0x50, 0x80, 0x05, 0x11, 0x20, 0x01, 0x35, 0xE2, 0x0D, 0x11, 0x20, 0x09, 0x38, 0x11, 0x47,
    0x47, 0x00, 0x1A, 0xFF, 0xFF, 0x00, 0x2A, 0x0D, 0x11, 0x20, 0x09, 0x42, 0xA4, 0x02, 0xD6, 0x83,
    0x00, 0xC8, 0x01, 0x80, 0xFF, 0x05, 0x11, 0x20, 0x01, 0x4C, 0x02, 0x05, 0x11, 0x20, 0x01, 0x4E,
    0x40, 0x05, 0x11, 0x20, 0x01, 0x51, 0x0A, 0x10, 0x11, 0x21, 0x0C, 0x00, 0xCC, 0xA1, 0x30, 0xA0,
    0x21, 0xD1, 0xB9, 0xC9, 0xEA, 0x05, 0x12, 0x11, 0x10, 0x11, 0x21, 0x0C, 0x0C, 0x0A, 0x04, 0x15,
    0xFC, 0x03, 0x00, 0xCC, 0xA1, 0x30, 0xA0, 0x21, 0xD1, 0x10, 0x11, 0x21, 0x0C, 0x18, 0xB9, 0xC9,
    0xEA, 0x05, 0x12, 0x11, 0x0A, 0x04, 0x15, 0xFC, 0x03, 0x00, 0x08, 0x11, 0x22, 0x04, 0x00, 0x08,
    0x60, 0x00, 0x3D, 0x0B, 0x11, 0x23, 0x07, 0x00, 0x2C, 0x0E, 0x0B, 0x04, 0x0C, 0x73, 0x03, 0x10,
    0x11, 0x30, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0C, 0x11, 0x40, 0x08, 0x00, 0x41, 0x0D, 0x03, 0xF0, 0x07, 0xE0, 0x20, 0xFE,
];

#[entry]
fn main() -> ! {
    let cp = cortex_m::Peripherals::take().unwrap();
    let dp = stm32f103xx_hal::stm32f103xx::Peripherals::take().unwrap();
    let mut flash = dp.FLASH.constrain();
    let mut rcc = dp.RCC.constrain();

    let mut afio = dp.AFIO.constrain(&mut rcc.apb2);

    let clocks = rcc.cfgr.freeze(&mut flash.acr);

    let mut gpioa = dp.GPIOA.split(&mut rcc.apb2);
    let mut gpiob = dp.GPIOB.split(&mut rcc.apb2);

    let sck = gpiob.pb3.into_alternate_push_pull(&mut gpiob.crl);
    let miso = gpiob.pb4.into_floating_input(&mut gpiob.crl);
    let mosi = gpiob.pb5.into_alternate_push_pull(&mut gpiob.crl);
    let cs = gpiob.pb6.into_push_pull_output(&mut gpiob.crl);
    let intr = gpiob.pb7.into_floating_input(&mut gpiob.crl);
    let sdn = gpiob.pb8.into_push_pull_output(&mut gpiob.crh);

    let spi1 = Spi::spi1(
        dp.SPI1,
        (sck, miso, mosi),
        &mut afio.mapr,
        Mode {
            // IMPORTANT: On most MCUs this is not the default mode.
            // If you use another one it may partially work but have completely unpredictable behavior.
            polarity: Polarity::IdleLow,
            phase: Phase::CaptureOnFirstTransition,
        },
        1.mhz(), // On a PCB 10MHz should be used
        clocks,
        &mut rcc.apb2,
    );

    let mut si4463 = Si446x::new(spi1, cs, sdn);

    let mut delay_provider = Delay::new(cp.SYST, clocks);

    // Resets the radio and feeds it the initialization vector from WDS
    si4463.reset(&mut delay_provider, Some(&INIT_VECTOR_PKT_433MHZ));

    // Send a 4 byte packet (that's what the init vector is configured for)
    let packet = [1, 2, 3, 4];
    si4463.write_tx_fifo(&packet);
    si4463.start_tx(None);
    loop {}
}
