//! An embedded_hal driver for the Si446x family by Silicon Labs
//!
//! Currently only handles packet mode using the built-in FIFOs. Configuration is still generated by WDS,
//! eventually we probably want a macro to configure the radio. Also this is currently only usable for blocking IO,
//! futures and async/await or an interrupt-driven model with DMA is probably more desirable.
//!
//! For debugging and development you probably want to enable the debug feature which will panic when an invalid
//! command is issued to the radio.
//!
//! Please have a look at the simple-tx example which does a pretty good job explaining how to get this driver running.
#![no_std]
#![feature(custom_attribute)]

use embedded_hal::blocking::delay::{DelayMs, DelayUs};
use embedded_hal::spi::FullDuplex;
use embedded_hal::digital::OutputPin;
use nb::block;
use core::fmt;
use core::fmt::{Debug, Display};
use panic_halt;

pub struct Si446x<SPI, CS, SDN> {
    spi: SPI,
    cs: CS,
    sdn: SDN,
}

#[derive(Debug)]
pub struct PartInfo {
    pub chip_rev: u8,
    pub part: u16,
    pub part_build: u8,
    pub id: u16,
    pub customer: u8,
    pub rom_id: u8,
}

#[derive(Debug, PartialEq, Eq)]
pub enum State {
    Undefined = 0x00,
    Sleep = 0x01,
    SPIActive = 0x02,
    Ready = 0x03,
    TuneTx = 0x05,
    TuneRx = 0x06,
    Tx = 0x07,
    Rx = 0x08,
}

impl State {
    fn from_u8(state: u8) -> State {
        match state {
            0x01 => State::Sleep,
            0x02 => State::SPIActive,
            0x03 => State::Ready,
            0x04 => State::Ready,
            0x05 => State::TuneTx,
            0x06 => State::TuneRx,
            0x07 => State::Tx,
            0x08 => State::Rx,
            _ => State::Undefined,
        }
    }
}

const DEBUG: bool = cfg!(feature = "debug");

impl Display for PartInfo {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Si{:x} Rev={} PartBuild={} Customer={} ID={} ROM={}",
            self.part, self.chip_rev, self.part_build, self.customer, self.id, self.rom_id
        )
    }
}

impl<E: Debug, SPI: FullDuplex<u8, Error = E>, CS: OutputPin, SDN: OutputPin> Si446x<SPI, CS, SDN> {
    pub fn new(spi: SPI, cs: CS, sdn: SDN) -> Self {
        Si446x {
            spi: spi,
            cs: cs,
            sdn: sdn,
        }
    }

    // Necessary to set cs back high after reading data
    fn wait_and_read_cmdbuf(&mut self, res: &mut [u8]) {
        loop {
            self.cs.set_low();
            block!(self.spi.send(0x44)).unwrap();
            block!(self.spi.read()).unwrap();
            block!(self.spi.send(0x00)).unwrap();
            if block!(self.spi.read()).unwrap() == 0xff {
                break;
            }
            self.cs.set_high();
        }
        for i in 0..res.len() {
            block!(self.spi.send(0x00)).unwrap();
            res[i] = block!(self.spi.read()).unwrap();
        }
        self.cs.set_high();
    }

    pub fn exec(&mut self, cmd: &[u8], res: &mut [u8]) {
        self.cs.set_low();
        for byte in cmd {
            block!(self.spi.send(*byte)).unwrap();
            block!(self.spi.read()).unwrap();
        }
        self.cs.set_high();

        self.wait_and_read_cmdbuf(res);
        if DEBUG && cmd[0] != 0x23 {
            let mut diag = [0u8; 4];
            self.exec(&[0x23, 0xff], &mut diag);
            if diag[0] & 0x8 > 0 {
                panic!("Si446x CMD failed: {:?} failed with state {}", cmd, diag[2]);
            }
        }
    }

    pub fn multi_exec(&mut self, cmds: &[u8]) {
        let mut pointer = 0;
        loop {
            if pointer >= cmds.len() {
                break;
            }
            let length = cmds[pointer];
            pointer += 1;
            self.exec(&cmds[pointer..(pointer + length as usize)], &mut []);
            pointer += length as usize;
        }
    }

    pub fn reset<D: DelayUs<u8> + DelayMs<u8>>(
        &mut self,
        delay_provider: &mut D,
        initial_configuration: Option<&[u8]>,
    ) {
        self.sdn.set_high();
        self.cs.set_high();
        delay_provider.delay_us(12); // 10 us spec + 2 us tolerance
        self.sdn.set_low();
        delay_provider.delay_ms(7); // 6ms spec  + 1ms tolerance
        self.wait_and_read_cmdbuf(&mut []); // Wait for CTS
        if let Some(initial_configuration) = initial_configuration {
            self.multi_exec(initial_configuration);
        }
    }

    pub fn get_part_info(&mut self) -> PartInfo {
        let mut res = [0u8; 8];
        self.exec(&[0x01], &mut res);
        PartInfo {
            chip_rev: res[0],
            part: ((res[1] as u16) << 8) | (res[2] as u16),
            part_build: res[3],
            id: ((res[4] as u16) << 8) | (res[5] as u16),
            customer: res[6],
            rom_id: res[7],
        }
    }
    pub fn clear_interrupts(&mut self) {
        self.exec(&[0x20], &mut []);
    }
    pub fn write_tx_fifo(&mut self, data: &[u8]) {
        self.cs.set_low();
        block!(self.spi.send(0x66)).unwrap();
        block!(self.spi.read()).unwrap();
        for byte in data {
            block!(self.spi.send(*byte)).unwrap();
            block!(self.spi.read()).unwrap();
        }
        self.cs.set_high();
    }
    pub fn read_rx_fifo(&mut self, data: &mut [u8]) {
        self.cs.set_low();
        block!(self.spi.send(0x77)).unwrap();
        block!(self.spi.read()).unwrap();
        for i in 0..data.len() {
            block!(self.spi.send(0x00)).unwrap();
            data[i] = block!(self.spi.read()).unwrap();
        }
        self.cs.set_high();
    }
    pub fn start_tx(&mut self, channel: Option<u8>) {
        match channel {
            None => self.exec(&[0x31], &mut []),
            Some(channel) => self.exec(&[0x31, channel], &mut []),
        }
    }
    pub fn start_rx(&mut self, channel: Option<u8>) {
        match channel {
            None => self.exec(&[0x32], &mut []),
            Some(channel) => self.exec(&[0x32, channel], &mut []),
        }
    }
    pub fn get_state(&mut self) -> (State, u8) {
        let mut res = [0; 2];
        self.exec(&[0x33], &mut res);
        (State::from_u8(res[0]), res[1])
    }
}
